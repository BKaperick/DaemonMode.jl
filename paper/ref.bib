@article{bezansonJuliaFreshApproach2017a,
  title = {Julia: {{A Fresh Approach}} to {{Numerical Computing}}},
  shorttitle = {Julia},
  author = {Bezanson, Jeff and Edelman, Alan and Karpinski, Stefan and Shah, Viral B.},
  year = {2017},
  month = jan,
  volume = {59},
  pages = {65--98},
  publisher = {{Society for Industrial and Applied Mathematics}},
  issn = {0036-1445},
  doi = {10.1137/141000671},
  abstract = {Bridging cultures that have often been distant, Julia combines expertise from the diverse fields of computer science and computational science to create a new approach to numerical  computing. Julia is  designed to be easy and fast and questions notions generally held to be ``laws of nature"  by practitioners of numerical computing: \textbackslash beginlist \textbackslash item  High-level dynamic programs have to be slow. \textbackslash item  One must prototype in one language and then rewrite in another language for speed or deployment. \textbackslash item There are parts of a system appropriate for the programmer, and other parts that are best left untouched as they have been built by the experts. \textbackslash endlist We introduce the  Julia programming language and its design---a  dance between specialization and abstraction. Specialization allows for custom treatment. Multiple dispatch,  a  technique from computer science, picks  the right algorithm for the right circumstance. Abstraction, which is what good computation is really about, recognizes what remains the same after differences are stripped away. Abstractions in mathematics are captured as code through another technique from computer science, generic programming. Julia shows that  one can achieve machine performance without sacrificing human convenience.},
  file = {/mnt/home/daniel/Zotero/storage/FD9VF69P/Bezanson et al. - 2017 - Julia A Fresh Approach to Numerical Computing.pdf;/mnt/home/daniel/Zotero/storage/EDQSDXVS/141000671.html},
  journal = {SIAM Review},
  number = {1}
}

@article{liAssessingOptimizingPerformance2019,
  title = {Assessing and Optimizing the Performance Impact of the Just-in-Time Configuration Parameters - a Case Study on {{PyPy}}},
  author = {Li, Yangguang and Jiang, Zhen Ming (Jack)},
  year = {2019},
  month = aug,
  volume = {24},
  pages = {2323--2363},
  issn = {1573-7616},
  doi = {10.1007/s10664-019-09691-z},
  abstract = {Many modern programming languages (e.g., Python, Java, and JavaScript) support just-in-time (JIT) compilation to speed up the execution of a software system. During runtime, the JIT compiler translates the frequently executed part of the system into efficient machine code, which can be executed much faster compared to the default interpreted mode. There are many JIT configuration parameters, which vary based on the programming languages and types of the jitting strategies (method vs. tracing-based). Although there are many existing works trying to improve various aspects of the jitting process, there are very few works which study the performance impact of the JIT configuration settings. In this paper, we performed an empirical study on the performance impact of the JIT configuration settings of PyPy. PyPy is a popular implementation of the Python programming language. Due to PyPy's efficient JIT compiler, running Python programs under PyPy is usually much faster than other alternative implementations of Python (e.g., cPython, Jython, and IronPython). To motivate the need for tuning PyPy's JIT configuration settings, we first performed an exploratory study on two microbenchmark suites. Our findings show that systems executed under PyPy's default JIT configuration setting may not yield the best performance. Optimal JIT configuration settings vary from systems to systems. Larger portions of the code being jitted do not necessarily lead to better performance. To cope with these findings, we developed an automated approach, ESM-MOGA, to tuning the JIT configuration settings. ESM-MOGA, which stands for effect-size measure-based multi-objective genetic algorithm, automatically explores the PyPy's JIT configuration settings for optimal solutions. Case studies on three open source systems show that systems running under the resulting configuration settings significantly out-perform (5\% - 60\% improvement in average peak performance) the default configuration settings.},
  file = {/mnt/home/daniel/Zotero/storage/HQ2A9V7G/Li and Jiang - 2019 - Assessing and optimizing the performance impact of.pdf},
  journal = {Empirical Software Engineering},
  language = {en},
  number = {4}
}

